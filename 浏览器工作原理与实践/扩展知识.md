### 浏览器上下文组

- 概念
  - 同源：协议、域名和端口相同
  - 同一站点：协议，根域名相同
- 标签页之间的连接(浏览上下文组)
  - <a>标签
  - window.open

```javascript
// windowA->windowB
var windowB = window.open("xxx");
// windowB->windowA, a标签新开标签页，获取不到opener，chrome最新版本不行？
window.opener;
```

- Chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中
  - 同一个浏览上下文组
  - 同一站点
- noopener 和 noreferrer
- 站点隔离
  - 标签页中的同一站点 iframe，共用渲染进程

### Chrome 任务调度

- 单消息队列的队头阻塞问题
  - 低优先级任务会阻塞高优先级任务
- 主线程任务：用户事件，合成任务，定时器，垃圾回收，网络加载，dom/css 解析，布局，js 运行等
- 队头阻塞问题解决方案
- 第一次迭代：引入一个高优先级队列
  - 问题：无法保证任务的相对执行顺序
- 第二次迭代：根据消息类型来实现消息队列
  - 类型：用户交互，合成页面，默认（js 执行，资源加载，定时器等），空闲（垃圾回收等低优先级）
  - 问题：静态优先级，加载阶段和交互阶段，任务的优先级不同
- 第三次迭代：动态调度策略
  - 加载阶段（优先级高->低）：默认 - 用户交互 - 合成页面 - 空闲
  - 用户交互阶段：用户交互 - 合成页面 - 默认 - 空闲
  - 空闲阶段：默认/用户交互 - 空闲 - 合成页面
- 渲染过程
  - 显卡：后缓冲区和前缓冲区存放
  - VSync：当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给 GPU
    - 显示器读取图片和浏览器生成图片同步（dom->合成）
- 第四次迭代：任务饿死
  - 执行一定数量的高优先级任务后，执行一次低优先级任务
- CSS 动画 和 requestAnimationFrame 优势
  - 保证动画执行的实际与 VSync 一致
