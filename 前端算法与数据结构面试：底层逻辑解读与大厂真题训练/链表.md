- 处理链表的本质，是处理链表结点之间的指针关系

### 链表合并（leetcode 21）

- 循环

```javascript
var mergeTwoLists = function (l1, l2) {
  let head = new ListNode(); // // 头节点
  let cur = head; // 指针
  // 遍历两个链表，cur的next指向val小的节点。
  // val小的节点链表节点后移，cur后移
  while (l1 && l2) {
    // ...
  }
  // 连接未遍历部分
  cur.next = l1 ? l1 : l2;
  return head.next;
};
```

- 递归

```javascript
var mergeTwoLists = function (l1, l2) {
  // 一个链表为空时，返回另外一个（递归终止条件）
  if (!l1) return l2;
  if (!l2) return l1;
  // 选择小的节点（递归函数）
  if (l1.val < l2.value) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  }
  // 同上
};
```

### 链表删除（leetcode 83）

```javascript
var deleteDuplicates = function (head) {
  // 指针
  var cur = head;
  while (cur && cur.next) {
    // 当前节点和下一节点重复，删除下一节点。否则循环链表节点
    // ...
  }
  return head;
};
```

### 链表删除 2（leetcode 82）

```javascript
var deleteDuplicates = function (head) {
  // 新增前驱节点（dummy）
  const newHead = new ListNode();
  newHead.next = head;
  // 指针
  let cur = newHead;
  while (cur.next && cur.next.next) {
    // 节点重复，删除重复的节点。否则继续遍历
    if (cur.next.val === cur.next.next.val) {
      // 删除两个重复节点
      // 继续删除重复节点
    } else {
      // ...
    }
  }
  return newHead.next;
};
```
